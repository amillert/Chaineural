(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@swimlane/ngx-charts'), require('d3-selection'), require('d3-shape'), require('d3-ease'), require('d3-transition'), require('rxjs'), require('rxjs/operators'), require('transformation-matrix'), require('dagre'), require('d3-force'), require('webcola'), require('d3-dispatch'), require('d3-timer')) :
    typeof define === 'function' && define.amd ? define('@swimlane/ngx-graph', ['exports', '@angular/core', '@swimlane/ngx-charts', 'd3-selection', 'd3-shape', 'd3-ease', 'd3-transition', 'rxjs', 'rxjs/operators', 'transformation-matrix', 'dagre', 'd3-force', 'webcola', 'd3-dispatch', 'd3-timer'], factory) :
    (global = global || self, factory((global.swimlane = global.swimlane || {}, global.swimlane['ngx-graph'] = {}), global.ng.core, global.ngxCharts, global.d3Selection, global.d3Shape, global.d3Ease, null, global.rxjs, global.rxjs.operators, global.transformationMatrix, global.dagre, global.d3Force, global.webcola, global.d3Dispatch, global.d3Timer));
}(this, function (exports, core, ngxCharts, d3Selection, d3Shape, d3Ease, d3Transition, rxjs, operators, transformationMatrix, dagre, d3Force, webcola, d3Dispatch, d3Timer) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var cache = {};
    /**
     * Generates a short id.
     *
     * @return {?}
     */
    function id() {
        /** @type {?} */
        var newId = ('0000' + ((Math.random() * Math.pow(36, 4)) << 0).toString(36)).slice(-4);
        newId = "a" + newId;
        // ensure not already used
        if (!cache[newId]) {
            cache[newId] = true;
            return newId;
        }
        return id();
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var Orientation = {
        LEFT_TO_RIGHT: 'LR',
        RIGHT_TO_LEFT: 'RL',
        TOP_TO_BOTTOM: 'TB',
        BOTTOM_TO_TOM: 'BT',
    };
    var DagreLayout = /** @class */ (function () {
        function DagreLayout() {
            this.defaultSettings = {
                orientation: Orientation.LEFT_TO_RIGHT,
                marginX: 20,
                marginY: 20,
                edgePadding: 100,
                rankPadding: 100,
                nodePadding: 50,
                multigraph: true,
                compound: true
            };
            this.settings = {};
        }
        /**
         * @param {?} graph
         * @return {?}
         */
        DagreLayout.prototype.run = /**
         * @param {?} graph
         * @return {?}
         */
        function (graph) {
            this.createDagreGraph(graph);
            dagre.layout(this.dagreGraph);
            graph.edgeLabels = this.dagreGraph._edgeLabels;
            var _loop_1 = function (dagreNodeId) {
                /** @type {?} */
                var dagreNode = this_1.dagreGraph._nodes[dagreNodeId];
                /** @type {?} */
                var node = graph.nodes.find((/**
                 * @param {?} n
                 * @return {?}
                 */
                function (n) { return n.id === dagreNode.id; }));
                node.position = {
                    x: dagreNode.x,
                    y: dagreNode.y
                };
                node.dimension = {
                    width: dagreNode.width,
                    height: dagreNode.height
                };
            };
            var this_1 = this;
            for (var dagreNodeId in this.dagreGraph._nodes) {
                _loop_1(dagreNodeId);
            }
            return graph;
        };
        /**
         * @param {?} graph
         * @param {?} edge
         * @return {?}
         */
        DagreLayout.prototype.updateEdge = /**
         * @param {?} graph
         * @param {?} edge
         * @return {?}
         */
        function (graph, edge) {
            /** @type {?} */
            var sourceNode = graph.nodes.find((/**
             * @param {?} n
             * @return {?}
             */
            function (n) { return n.id === edge.source; }));
            /** @type {?} */
            var targetNode = graph.nodes.find((/**
             * @param {?} n
             * @return {?}
             */
            function (n) { return n.id === edge.target; }));
            // determine new arrow position
            /** @type {?} */
            var dir = sourceNode.position.y <= targetNode.position.y ? -1 : 1;
            /** @type {?} */
            var startingPoint = {
                x: sourceNode.position.x,
                y: sourceNode.position.y - dir * (sourceNode.dimension.height / 2)
            };
            /** @type {?} */
            var endingPoint = {
                x: targetNode.position.x,
                y: targetNode.position.y + dir * (targetNode.dimension.height / 2)
            };
            // generate new points
            edge.points = [startingPoint, endingPoint];
            return graph;
        };
        /**
         * @param {?} graph
         * @return {?}
         */
        DagreLayout.prototype.createDagreGraph = /**
         * @param {?} graph
         * @return {?}
         */
        function (graph) {
            var e_1, _a, e_2, _b;
            /** @type {?} */
            var settings = Object.assign({}, this.defaultSettings, this.settings);
            this.dagreGraph = new dagre.graphlib.Graph({ compound: settings.compound, multigraph: settings.multigraph });
            this.dagreGraph.setGraph({
                rankdir: settings.orientation,
                marginx: settings.marginX,
                marginy: settings.marginY,
                edgesep: settings.edgePadding,
                ranksep: settings.rankPadding,
                nodesep: settings.nodePadding,
                align: settings.align,
                acyclicer: settings.acyclicer,
                ranker: settings.ranker,
                multigraph: settings.multigraph,
                compound: settings.compound
            });
            // Default to assigning a new object as a label for each new edge.
            this.dagreGraph.setDefaultEdgeLabel((/**
             * @return {?}
             */
            function () {
                return {
                /* empty */
                };
            }));
            this.dagreNodes = graph.nodes.map((/**
             * @param {?} n
             * @return {?}
             */
            function (n) {
                /** @type {?} */
                var node = Object.assign({}, n);
                node.width = n.dimension.width;
                node.height = n.dimension.height;
                node.x = n.position.x;
                node.y = n.position.y;
                return node;
            }));
            this.dagreEdges = graph.edges.map((/**
             * @param {?} l
             * @return {?}
             */
            function (l) {
                /** @type {?} */
                var newLink = Object.assign({}, l);
                if (!newLink.id) {
                    newLink.id = id();
                }
                return newLink;
            }));
            try {
                for (var _c = __values(this.dagreNodes), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var node = _d.value;
                    if (!node.width) {
                        node.width = 20;
                    }
                    if (!node.height) {
                        node.height = 30;
                    }
                    // update dagre
                    this.dagreGraph.setNode(node.id, node);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            try {
                // update dagre
                for (var _e = __values(this.dagreEdges), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var edge = _f.value;
                    if (settings.multigraph) {
                        this.dagreGraph.setEdge(edge.source, edge.target, edge, edge.id);
                    }
                    else {
                        this.dagreGraph.setEdge(edge.source, edge.target);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return this.dagreGraph;
        };
        return DagreLayout;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var DagreClusterLayout = /** @class */ (function () {
        function DagreClusterLayout() {
            this.defaultSettings = {
                orientation: Orientation.LEFT_TO_RIGHT,
                marginX: 20,
                marginY: 20,
                edgePadding: 100,
                rankPadding: 100,
                nodePadding: 50,
                multigraph: true,
                compound: true
            };
            this.settings = {};
        }
        /**
         * @param {?} graph
         * @return {?}
         */
        DagreClusterLayout.prototype.run = /**
         * @param {?} graph
         * @return {?}
         */
        function (graph) {
            var _this = this;
            this.createDagreGraph(graph);
            dagre.layout(this.dagreGraph);
            graph.edgeLabels = this.dagreGraph._edgeLabels;
            /** @type {?} */
            var dagreToOutput = (/**
             * @param {?} node
             * @return {?}
             */
            function (node) {
                /** @type {?} */
                var dagreNode = _this.dagreGraph._nodes[node.id];
                return __assign({}, node, { position: {
                        x: dagreNode.x,
                        y: dagreNode.y
                    }, dimension: {
                        width: dagreNode.width,
                        height: dagreNode.height
                    } });
            });
            graph.clusters = (graph.clusters || []).map(dagreToOutput);
            graph.nodes = graph.nodes.map(dagreToOutput);
            return graph;
        };
        /**
         * @param {?} graph
         * @param {?} edge
         * @return {?}
         */
        DagreClusterLayout.prototype.updateEdge = /**
         * @param {?} graph
         * @param {?} edge
         * @return {?}
         */
        function (graph, edge) {
            /** @type {?} */
            var sourceNode = graph.nodes.find((/**
             * @param {?} n
             * @return {?}
             */
            function (n) { return n.id === edge.source; }));
            /** @type {?} */
            var targetNode = graph.nodes.find((/**
             * @param {?} n
             * @return {?}
             */
            function (n) { return n.id === edge.target; }));
            // determine new arrow position
            /** @type {?} */
            var dir = sourceNode.position.y <= targetNode.position.y ? -1 : 1;
            /** @type {?} */
            var startingPoint = {
                x: sourceNode.position.x,
                y: sourceNode.position.y - dir * (sourceNode.dimension.height / 2)
            };
            /** @type {?} */
            var endingPoint = {
                x: targetNode.position.x,
                y: targetNode.position.y + dir * (targetNode.dimension.height / 2)
            };
            // generate new points
            edge.points = [startingPoint, endingPoint];
            return graph;
        };
        /**
         * @param {?} graph
         * @return {?}
         */
        DagreClusterLayout.prototype.createDagreGraph = /**
         * @param {?} graph
         * @return {?}
         */
        function (graph) {
            var _this = this;
            var e_1, _a, e_2, _b, e_3, _c;
            /** @type {?} */
            var settings = Object.assign({}, this.defaultSettings, this.settings);
            this.dagreGraph = new dagre.graphlib.Graph({ compound: settings.compound, multigraph: settings.multigraph });
            this.dagreGraph.setGraph({
                rankdir: settings.orientation,
                marginx: settings.marginX,
                marginy: settings.marginY,
                edgesep: settings.edgePadding,
                ranksep: settings.rankPadding,
                nodesep: settings.nodePadding,
                align: settings.align,
                acyclicer: settings.acyclicer,
                ranker: settings.ranker,
                multigraph: settings.multigraph,
                compound: settings.compound
            });
            // Default to assigning a new object as a label for each new edge.
            this.dagreGraph.setDefaultEdgeLabel((/**
             * @return {?}
             */
            function () {
                return {
                /* empty */
                };
            }));
            this.dagreNodes = graph.nodes.map((/**
             * @param {?} n
             * @return {?}
             */
            function (n) {
                /** @type {?} */
                var node = Object.assign({}, n);
                node.width = n.dimension.width;
                node.height = n.dimension.height;
                node.x = n.position.x;
                node.y = n.position.y;
                return node;
            }));
            this.dagreClusters = graph.clusters || [];
            this.dagreEdges = graph.edges.map((/**
             * @param {?} l
             * @return {?}
             */
            function (l) {
                /** @type {?} */
                var newLink = Object.assign({}, l);
                if (!newLink.id) {
                    newLink.id = id();
                }
                return newLink;
            }));
            try {
                for (var _d = __values(this.dagreNodes), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var node = _e.value;
                    this.dagreGraph.setNode(node.id, node);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_1) throw e_1.error; }
            }
            var _loop_1 = function (cluster) {
                this_1.dagreGraph.setNode(cluster.id, cluster);
                cluster.childNodeIds.forEach((/**
                 * @param {?} childNodeId
                 * @return {?}
                 */
                function (childNodeId) {
                    _this.dagreGraph.setParent(childNodeId, cluster.id);
                }));
            };
            var this_1 = this;
            try {
                for (var _f = __values(this.dagreClusters), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var cluster = _g.value;
                    _loop_1(cluster);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                }
                finally { if (e_2) throw e_2.error; }
            }
            try {
                // update dagre
                for (var _h = __values(this.dagreEdges), _j = _h.next(); !_j.done; _j = _h.next()) {
                    var edge = _j.value;
                    if (settings.multigraph) {
                        this.dagreGraph.setEdge(edge.source, edge.target, edge, edge.id);
                    }
                    else {
                        this.dagreGraph.setEdge(edge.source, edge.target);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return this.dagreGraph;
        };
        return DagreClusterLayout;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var Orientation$1 = {
        LEFT_TO_RIGHT: 'LR',
        RIGHT_TO_LEFT: 'RL',
        TOP_TO_BOTTOM: 'TB',
        BOTTOM_TO_TOM: 'BT',
    };
    /** @type {?} */
    var DEFAULT_EDGE_NAME = '\x00';
    /** @type {?} */
    var EDGE_KEY_DELIM = '\x01';
    var DagreNodesOnlyLayout = /** @class */ (function () {
        function DagreNodesOnlyLayout() {
            this.defaultSettings = {
                orientation: Orientation$1.LEFT_TO_RIGHT,
                marginX: 20,
                marginY: 20,
                edgePadding: 100,
                rankPadding: 100,
                nodePadding: 50,
                curveDistance: 20,
                multigraph: true,
                compound: true
            };
            this.settings = {};
        }
        /**
         * @param {?} graph
         * @return {?}
         */
        DagreNodesOnlyLayout.prototype.run = /**
         * @param {?} graph
         * @return {?}
         */
        function (graph) {
            var e_1, _a;
            this.createDagreGraph(graph);
            dagre.layout(this.dagreGraph);
            graph.edgeLabels = this.dagreGraph._edgeLabels;
            var _loop_1 = function (dagreNodeId) {
                /** @type {?} */
                var dagreNode = this_1.dagreGraph._nodes[dagreNodeId];
                /** @type {?} */
                var node = graph.nodes.find((/**
                 * @param {?} n
                 * @return {?}
                 */
                function (n) { return n.id === dagreNode.id; }));
                node.position = {
                    x: dagreNode.x,
                    y: dagreNode.y
                };
                node.dimension = {
                    width: dagreNode.width,
                    height: dagreNode.height
                };
            };
            var this_1 = this;
            for (var dagreNodeId in this.dagreGraph._nodes) {
                _loop_1(dagreNodeId);
            }
            try {
                for (var _b = __values(graph.edges), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var edge = _c.value;
                    this.updateEdge(graph, edge);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return graph;
        };
        /**
         * @param {?} graph
         * @param {?} edge
         * @return {?}
         */
        DagreNodesOnlyLayout.prototype.updateEdge = /**
         * @param {?} graph
         * @param {?} edge
         * @return {?}
         */
        function (graph, edge) {
            var _a, _b, _c, _d;
            /** @type {?} */
            var sourceNode = graph.nodes.find((/**
             * @param {?} n
             * @return {?}
             */
            function (n) { return n.id === edge.source; }));
            /** @type {?} */
            var targetNode = graph.nodes.find((/**
             * @param {?} n
             * @return {?}
             */
            function (n) { return n.id === edge.target; }));
            /** @type {?} */
            var rankAxis = this.settings.orientation === 'BT' || this.settings.orientation === 'TB' ? 'y' : 'x';
            /** @type {?} */
            var orderAxis = rankAxis === 'y' ? 'x' : 'y';
            /** @type {?} */
            var rankDimension = rankAxis === 'y' ? 'height' : 'width';
            // determine new arrow position
            /** @type {?} */
            var dir = sourceNode.position[rankAxis] <= targetNode.position[rankAxis] ? -1 : 1;
            /** @type {?} */
            var startingPoint = (_a = {},
                _a[orderAxis] = sourceNode.position[orderAxis],
                _a[rankAxis] = sourceNode.position[rankAxis] - dir * (sourceNode.dimension[rankDimension] / 2),
                _a);
            /** @type {?} */
            var endingPoint = (_b = {},
                _b[orderAxis] = targetNode.position[orderAxis],
                _b[rankAxis] = targetNode.position[rankAxis] + dir * (targetNode.dimension[rankDimension] / 2),
                _b);
            /** @type {?} */
            var curveDistance = this.settings.curveDistance || this.defaultSettings.curveDistance;
            // generate new points
            edge.points = [
                startingPoint,
                (_c = {},
                    _c[orderAxis] = startingPoint[orderAxis],
                    _c[rankAxis] = startingPoint[rankAxis] - dir * curveDistance,
                    _c),
                (_d = {},
                    _d[orderAxis] = endingPoint[orderAxis],
                    _d[rankAxis] = endingPoint[rankAxis] + dir * curveDistance,
                    _d),
                endingPoint
            ];
            /** @type {?} */
            var edgeLabelId = "" + edge.source + EDGE_KEY_DELIM + edge.target + EDGE_KEY_DELIM + DEFAULT_EDGE_NAME;
            /** @type {?} */
            var matchingEdgeLabel = graph.edgeLabels[edgeLabelId];
            if (matchingEdgeLabel) {
                matchingEdgeLabel.points = edge.points;
            }
            return graph;
        };
        /**
         * @param {?} graph
         * @return {?}
         */
        DagreNodesOnlyLayout.prototype.createDagreGraph = /**
         * @param {?} graph
         * @return {?}
         */
        function (graph) {
            var e_2, _a, e_3, _b;
            /** @type {?} */
            var settings = Object.assign({}, this.defaultSettings, this.settings);
            this.dagreGraph = new dagre.graphlib.Graph({ compound: settings.compound, multigraph: settings.multigraph });
            this.dagreGraph.setGraph({
                rankdir: settings.orientation,
                marginx: settings.marginX,
                marginy: settings.marginY,
                edgesep: settings.edgePadding,
                ranksep: settings.rankPadding,
                nodesep: settings.nodePadding,
                align: settings.align,
                acyclicer: settings.acyclicer,
                ranker: settings.ranker,
                multigraph: settings.multigraph,
                compound: settings.compound
            });
            // Default to assigning a new object as a label for each new edge.
            this.dagreGraph.setDefaultEdgeLabel((/**
             * @return {?}
             */
            function () {
                return {
                /* empty */
                };
            }));
            this.dagreNodes = graph.nodes.map((/**
             * @param {?} n
             * @return {?}
             */
            function (n) {
                /** @type {?} */
                var node = Object.assign({}, n);
                node.width = n.dimension.width;
                node.height = n.dimension.height;
                node.x = n.position.x;
                node.y = n.position.y;
                return node;
            }));
            this.dagreEdges = graph.edges.map((/**
             * @param {?} l
             * @return {?}
             */
            function (l) {
                /** @type {?} */
                var newLink = Object.assign({}, l);
                if (!newLink.id) {
                    newLink.id = id();
                }
                return newLink;
            }));
            try {
                for (var _c = __values(this.dagreNodes), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var node = _d.value;
                    if (!node.width) {
                        node.width = 20;
                    }
                    if (!node.height) {
                        node.height = 30;
                    }
                    // update dagre
                    this.dagreGraph.setNode(node.id, node);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            try {
                // update dagre
                for (var _e = __values(this.dagreEdges), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var edge = _f.value;
                    if (settings.multigraph) {
                        this.dagreGraph.setEdge(edge.source, edge.target, edge, edge.id);
                    }
                    else {
                        this.dagreGraph.setEdge(edge.source, edge.target);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return this.dagreGraph;
        };
        return DagreNodesOnlyLayout;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} maybeNode
     * @return {?}
     */
    function toD3Node(maybeNode) {
        if (typeof maybeNode === 'string') {
            return {
                id: maybeNode,
                x: 0,
                y: 0
            };
        }
        return maybeNode;
    }
    var D3ForceDirectedLayout = /** @class */ (function () {
        function D3ForceDirectedLayout() {
            this.defaultSettings = {
                force: d3Force.forceSimulation()
                    .force('charge', d3Force.forceManyBody().strength(-150))
                    .force('collide', d3Force.forceCollide(5)),
                forceLink: d3Force.forceLink()
                    .id((/**
                 * @param {?} node
                 * @return {?}
                 */
                function (node) { return node.id; }))
                    .distance((/**
                 * @return {?}
                 */
                function () { return 100; }))
            };
            this.settings = {};
            this.outputGraph$ = new rxjs.Subject();
        }
        /**
         * @param {?} graph
         * @return {?}
         */
        D3ForceDirectedLayout.prototype.run = /**
         * @param {?} graph
         * @return {?}
         */
        function (graph) {
            var _this = this;
            this.inputGraph = graph;
            this.d3Graph = {
                nodes: (/** @type {?} */ (__spread(this.inputGraph.nodes.map((/**
                 * @param {?} n
                 * @return {?}
                 */
                function (n) { return (__assign({}, n)); }))))),
                edges: (/** @type {?} */ (__spread(this.inputGraph.edges.map((/**
                 * @param {?} e
                 * @return {?}
                 */
                function (e) { return (__assign({}, e)); })))))
            };
            this.outputGraph = {
                nodes: [],
                edges: [],
                edgeLabels: []
            };
            this.outputGraph$.next(this.outputGraph);
            this.settings = Object.assign({}, this.defaultSettings, this.settings);
            if (this.settings.force) {
                this.settings.force
                    .nodes(this.d3Graph.nodes)
                    .force('link', this.settings.forceLink.links(this.d3Graph.edges))
                    .alpha(0.5)
                    .restart()
                    .on('tick', (/**
                 * @return {?}
                 */
                function () {
                    _this.outputGraph$.next(_this.d3GraphToOutputGraph(_this.d3Graph));
                }));
            }
            return this.outputGraph$.asObservable();
        };
        /**
         * @param {?} graph
         * @param {?} edge
         * @return {?}
         */
        D3ForceDirectedLayout.prototype.updateEdge = /**
         * @param {?} graph
         * @param {?} edge
         * @return {?}
         */
        function (graph, edge) {
            var _this = this;
            /** @type {?} */
            var settings = Object.assign({}, this.defaultSettings, this.settings);
            if (settings.force) {
                settings.force
                    .nodes(this.d3Graph.nodes)
                    .force('link', settings.forceLink.links(this.d3Graph.edges))
                    .alpha(0.5)
                    .restart()
                    .on('tick', (/**
                 * @return {?}
                 */
                function () {
                    _this.outputGraph$.next(_this.d3GraphToOutputGraph(_this.d3Graph));
                }));
            }
            return this.outputGraph$.asObservable();
        };
        /**
         * @param {?} d3Graph
         * @return {?}
         */
        D3ForceDirectedLayout.prototype.d3GraphToOutputGraph = /**
         * @param {?} d3Graph
         * @return {?}
         */
        function (d3Graph) {
            this.outputGraph.nodes = this.d3Graph.nodes.map((/**
             * @param {?} node
             * @return {?}
             */
            function (node) { return (__assign({}, node, { id: node.id || id(), position: {
                    x: node.x,
                    y: node.y
                }, dimension: {
                    width: (node.dimension && node.dimension.width) || 20,
                    height: (node.dimension && node.dimension.height) || 20
                }, transform: "translate(" + (node.x - ((node.dimension && node.dimension.width) || 20) / 2 || 0) + ", " + (node.y -
                    ((node.dimension && node.dimension.height) || 20) / 2 || 0) + ")" })); }));
            this.outputGraph.edges = this.d3Graph.edges.map((/**
             * @param {?} edge
             * @return {?}
             */
            function (edge) { return (__assign({}, edge, { source: toD3Node(edge.source).id, target: toD3Node(edge.target).id, points: [
                    {
                        x: toD3Node(edge.source).x,
                        y: toD3Node(edge.source).y
                    },
                    {
                        x: toD3Node(edge.target).x,
                        y: toD3Node(edge.target).y
                    }
                ] })); }));
            this.outputGraph.edgeLabels = this.outputGraph.edges;
            return this.outputGraph;
        };
        /**
         * @param {?} draggingNode
         * @param {?} $event
         * @return {?}
         */
        D3ForceDirectedLayout.prototype.onDragStart = /**
         * @param {?} draggingNode
         * @param {?} $event
         * @return {?}
         */
        function (draggingNode, $event) {
            this.settings.force.alphaTarget(0.3).restart();
            /** @type {?} */
            var node = this.d3Graph.nodes.find((/**
             * @param {?} d3Node
             * @return {?}
             */
            function (d3Node) { return d3Node.id === draggingNode.id; }));
            if (!node) {
                return;
            }
            this.draggingStart = { x: $event.x - node.x, y: $event.y - node.y };
            node.fx = $event.x - this.draggingStart.x;
            node.fy = $event.y - this.draggingStart.y;
        };
        /**
         * @param {?} draggingNode
         * @param {?} $event
         * @return {?}
         */
        D3ForceDirectedLayout.prototype.onDrag = /**
         * @param {?} draggingNode
         * @param {?} $event
         * @return {?}
         */
        function (draggingNode, $event) {
            if (!draggingNode) {
                return;
            }
            /** @type {?} */
            var node = this.d3Graph.nodes.find((/**
             * @param {?} d3Node
             * @return {?}
             */
            function (d3Node) { return d3Node.id === draggingNode.id; }));
            if (!node) {
                return;
            }
            node.fx = $event.x - this.draggingStart.x;
            node.fy = $event.y - this.draggingStart.y;
        };
        /**
         * @param {?} draggingNode
         * @param {?} $event
         * @return {?}
         */
        D3ForceDirectedLayout.prototype.onDragEnd = /**
         * @param {?} draggingNode
         * @param {?} $event
         * @return {?}
         */
        function (draggingNode, $event) {
            if (!draggingNode) {
                return;
            }
            /** @type {?} */
            var node = this.d3Graph.nodes.find((/**
             * @param {?} d3Node
             * @return {?}
             */
            function (d3Node) { return d3Node.id === draggingNode.id; }));
            if (!node) {
                return;
            }
            this.settings.force.alphaTarget(0);
            node.fx = undefined;
            node.fy = undefined;
        };
        return D3ForceDirectedLayout;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} nodes
     * @param {?} nodeRef
     * @return {?}
     */
    function toNode(nodes, nodeRef) {
        if (typeof nodeRef === 'number') {
            return nodes[nodeRef];
        }
        return nodeRef;
    }
    var ColaForceDirectedLayout = /** @class */ (function () {
        function ColaForceDirectedLayout() {
            this.defaultSettings = {
                force: webcola.d3adaptor(__assign({}, d3Dispatch, d3Force, d3Timer))
                    .linkDistance(150)
                    .avoidOverlaps(true),
                viewDimensions: {
                    width: 600,
                    height: 600,
                    xOffset: 0
                }
            };
            this.settings = {};
            this.outputGraph$ = new rxjs.Subject();
        }
        /**
         * @param {?} graph
         * @return {?}
         */
        ColaForceDirectedLayout.prototype.run = /**
         * @param {?} graph
         * @return {?}
         */
        function (graph) {
            var _this = this;
            this.inputGraph = graph;
            if (!this.inputGraph.clusters) {
                this.inputGraph.clusters = [];
            }
            this.internalGraph = {
                nodes: (/** @type {?} */ (__spread(this.inputGraph.nodes.map((/**
                 * @param {?} n
                 * @return {?}
                 */
                function (n) { return (__assign({}, n, { width: n.dimension ? n.dimension.width : 20, height: n.dimension ? n.dimension.height : 20 })); }))))),
                groups: __spread(this.inputGraph.clusters.map((/**
                 * @param {?} cluster
                 * @return {?}
                 */
                function (cluster) { return ({
                    padding: 5,
                    groups: cluster.childNodeIds
                        .map((/**
                     * @param {?} nodeId
                     * @return {?}
                     */
                    function (nodeId) { return (/** @type {?} */ (_this.inputGraph.clusters.findIndex((/**
                     * @param {?} node
                     * @return {?}
                     */
                    function (node) { return node.id === nodeId; })))); }))
                        .filter((/**
                     * @param {?} x
                     * @return {?}
                     */
                    function (x) { return x >= 0; })),
                    leaves: cluster.childNodeIds
                        .map((/**
                     * @param {?} nodeId
                     * @return {?}
                     */
                    function (nodeId) { return (/** @type {?} */ (_this.inputGraph.nodes.findIndex((/**
                     * @param {?} node
                     * @return {?}
                     */
                    function (node) { return node.id === nodeId; })))); }))
                        .filter((/**
                     * @param {?} x
                     * @return {?}
                     */
                    function (x) { return x >= 0; }))
                }); }))),
                links: (/** @type {?} */ (__spread(this.inputGraph.edges
                    .map((/**
                 * @param {?} e
                 * @return {?}
                 */
                function (e) {
                    /** @type {?} */
                    var sourceNodeIndex = _this.inputGraph.nodes.findIndex((/**
                     * @param {?} node
                     * @return {?}
                     */
                    function (node) { return e.source === node.id; }));
                    /** @type {?} */
                    var targetNodeIndex = _this.inputGraph.nodes.findIndex((/**
                     * @param {?} node
                     * @return {?}
                     */
                    function (node) { return e.target === node.id; }));
                    if (sourceNodeIndex === -1 || targetNodeIndex === -1) {
                        return undefined;
                    }
                    return __assign({}, e, { source: sourceNodeIndex, target: targetNodeIndex });
                }))
                    .filter((/**
                 * @param {?} x
                 * @return {?}
                 */
                function (x) { return !!x; }))))),
                groupLinks: __spread(this.inputGraph.edges
                    .map((/**
                 * @param {?} e
                 * @return {?}
                 */
                function (e) {
                    /** @type {?} */
                    var sourceNodeIndex = _this.inputGraph.nodes.findIndex((/**
                     * @param {?} node
                     * @return {?}
                     */
                    function (node) { return e.source === node.id; }));
                    /** @type {?} */
                    var targetNodeIndex = _this.inputGraph.nodes.findIndex((/**
                     * @param {?} node
                     * @return {?}
                     */
                    function (node) { return e.target === node.id; }));
                    if (sourceNodeIndex >= 0 && targetNodeIndex >= 0) {
                        return undefined;
                    }
                    return e;
                }))
                    .filter((/**
                 * @param {?} x
                 * @return {?}
                 */
                function (x) { return !!x; })))
            };
            this.outputGraph = {
                nodes: [],
                clusters: [],
                edges: [],
                edgeLabels: []
            };
            this.outputGraph$.next(this.outputGraph);
            this.settings = Object.assign({}, this.defaultSettings, this.settings);
            if (this.settings.force) {
                this.settings.force = this.settings.force
                    .nodes(this.internalGraph.nodes)
                    .groups(this.internalGraph.groups)
                    .links(this.internalGraph.links)
                    .alpha(0.5)
                    .on('tick', (/**
                 * @return {?}
                 */
                function () {
                    if (_this.settings.onTickListener) {
                        _this.settings.onTickListener(_this.internalGraph);
                    }
                    _this.outputGraph$.next(_this.internalGraphToOutputGraph(_this.internalGraph));
                }));
                if (this.settings.viewDimensions) {
                    this.settings.force = this.settings.force.size([
                        this.settings.viewDimensions.width,
                        this.settings.viewDimensions.height
                    ]);
                }
                if (this.settings.forceModifierFn) {
                    this.settings.force = this.settings.forceModifierFn(this.settings.force);
                }
                this.settings.force.start();
            }
            return this.outputGraph$.asObservable();
        };
        /**
         * @param {?} graph
         * @param {?} edge
         * @return {?}
         */
        ColaForceDirectedLayout.prototype.updateEdge = /**
         * @param {?} graph
         * @param {?} edge
         * @return {?}
         */
        function (graph, edge) {
            /** @type {?} */
            var settings = Object.assign({}, this.defaultSettings, this.settings);
            if (settings.force) {
                settings.force.start();
            }
            return this.outputGraph$.asObservable();
        };
        /**
         * @param {?} internalGraph
         * @return {?}
         */
        ColaForceDirectedLayout.prototype.internalGraphToOutputGraph = /**
         * @param {?} internalGraph
         * @return {?}
         */
        function (internalGraph) {
            var _this = this;
            this.outputGraph.nodes = internalGraph.nodes.map((/**
             * @param {?} node
             * @return {?}
             */
            function (node) { return (__assign({}, node, { id: node.id || id(), position: {
                    x: node.x,
                    y: node.y
                }, dimension: {
                    width: (node.dimension && node.dimension.width) || 20,
                    height: (node.dimension && node.dimension.height) || 20
                }, transform: "translate(" + (node.x - ((node.dimension && node.dimension.width) || 20) / 2 || 0) + ", " + (node.y -
                    ((node.dimension && node.dimension.height) || 20) / 2 || 0) + ")" })); }));
            this.outputGraph.edges = internalGraph.links
                .map((/**
             * @param {?} edge
             * @return {?}
             */
            function (edge) {
                /** @type {?} */
                var source = toNode(internalGraph.nodes, edge.source);
                /** @type {?} */
                var target = toNode(internalGraph.nodes, edge.target);
                return __assign({}, edge, { source: source.id, target: target.id, points: [
                        ((/** @type {?} */ (source.bounds))).rayIntersection(target.bounds.cx(), target.bounds.cy()),
                        ((/** @type {?} */ (target.bounds))).rayIntersection(source.bounds.cx(), source.bounds.cy())
                    ] });
            }))
                .concat(internalGraph.groupLinks.map((/**
             * @param {?} groupLink
             * @return {?}
             */
            function (groupLink) {
                /** @type {?} */
                var sourceNode = internalGraph.nodes.find((/**
                 * @param {?} foundNode
                 * @return {?}
                 */
                function (foundNode) { return ((/** @type {?} */ (foundNode))).id === groupLink.source; }));
                /** @type {?} */
                var targetNode = internalGraph.nodes.find((/**
                 * @param {?} foundNode
                 * @return {?}
                 */
                function (foundNode) { return ((/** @type {?} */ (foundNode))).id === groupLink.target; }));
                /** @type {?} */
                var source = sourceNode || internalGraph.groups.find((/**
                 * @param {?} foundGroup
                 * @return {?}
                 */
                function (foundGroup) { return ((/** @type {?} */ (foundGroup))).id === groupLink.source; }));
                /** @type {?} */
                var target = targetNode || internalGraph.groups.find((/**
                 * @param {?} foundGroup
                 * @return {?}
                 */
                function (foundGroup) { return ((/** @type {?} */ (foundGroup))).id === groupLink.target; }));
                return __assign({}, groupLink, { source: source.id, target: target.id, points: [
                        ((/** @type {?} */ (source.bounds))).rayIntersection(target.bounds.cx(), target.bounds.cy()),
                        ((/** @type {?} */ (target.bounds))).rayIntersection(source.bounds.cx(), source.bounds.cy())
                    ] });
            })));
            this.outputGraph.clusters = internalGraph.groups.map((/**
             * @param {?} group
             * @param {?} index
             * @return {?}
             */
            function (group, index) {
                /** @type {?} */
                var inputGroup = _this.inputGraph.clusters[index];
                return __assign({}, inputGroup, { dimension: {
                        width: group.bounds ? group.bounds.width() : 20,
                        height: group.bounds ? group.bounds.height() : 20
                    }, position: {
                        x: group.bounds ? group.bounds.x + group.bounds.width() / 2 : 0,
                        y: group.bounds ? group.bounds.y + group.bounds.height() / 2 : 0
                    } });
            }));
            this.outputGraph.edgeLabels = this.outputGraph.edges;
            return this.outputGraph;
        };
        /**
         * @param {?} draggingNode
         * @param {?} $event
         * @return {?}
         */
        ColaForceDirectedLayout.prototype.onDragStart = /**
         * @param {?} draggingNode
         * @param {?} $event
         * @return {?}
         */
        function (draggingNode, $event) {
            /** @type {?} */
            var nodeIndex = this.outputGraph.nodes.findIndex((/**
             * @param {?} foundNode
             * @return {?}
             */
            function (foundNode) { return foundNode.id === draggingNode.id; }));
            /** @type {?} */
            var node = this.internalGraph.nodes[nodeIndex];
            if (!node) {
                return;
            }
            this.draggingStart = { x: node.x - $event.x, y: node.y - $event.y };
            node.fixed = 1;
            this.settings.force.start();
        };
        /**
         * @param {?} draggingNode
         * @param {?} $event
         * @return {?}
         */
        ColaForceDirectedLayout.prototype.onDrag = /**
         * @param {?} draggingNode
         * @param {?} $event
         * @return {?}
         */
        function (draggingNode, $event) {
            if (!draggingNode) {
                return;
            }
            /** @type {?} */
            var nodeIndex = this.outputGraph.nodes.findIndex((/**
             * @param {?} foundNode
             * @return {?}
             */
            function (foundNode) { return foundNode.id === draggingNode.id; }));
            /** @type {?} */
            var node = this.internalGraph.nodes[nodeIndex];
            if (!node) {
                return;
            }
            node.x = this.draggingStart.x + $event.x;
            node.y = this.draggingStart.y + $event.y;
        };
        /**
         * @param {?} draggingNode
         * @param {?} $event
         * @return {?}
         */
        ColaForceDirectedLayout.prototype.onDragEnd = /**
         * @param {?} draggingNode
         * @param {?} $event
         * @return {?}
         */
        function (draggingNode, $event) {
            if (!draggingNode) {
                return;
            }
            /** @type {?} */
            var nodeIndex = this.outputGraph.nodes.findIndex((/**
             * @param {?} foundNode
             * @return {?}
             */
            function (foundNode) { return foundNode.id === draggingNode.id; }));
            /** @type {?} */
            var node = this.internalGraph.nodes[nodeIndex];
            if (!node) {
                return;
            }
            node.fixed = 0;
        };
        return ColaForceDirectedLayout;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var layouts = {
        dagre: DagreLayout,
        dagreCluster: DagreClusterLayout,
        dagreNodesOnly: DagreNodesOnlyLayout,
        d3ForceDirected: D3ForceDirectedLayout,
        colaForceDirected: ColaForceDirectedLayout
    };
    var LayoutService = /** @class */ (function () {
        function LayoutService() {
        }
        /**
         * @param {?} name
         * @return {?}
         */
        LayoutService.prototype.getLayout = /**
         * @param {?} name
         * @return {?}
         */
        function (name) {
            if (layouts[name]) {
                return new layouts[name]();
            }
            else {
                throw new Error("Unknown layout type '" + name + "'");
            }
        };
        LayoutService.decorators = [
            { type: core.Injectable }
        ];
        return LayoutService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var PanningAxis = {
        Both: 'both',
        Horizontal: 'horizontal',
        Vertical: 'vertical',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var GraphComponent = /** @class */ (function (_super) {
        __extends(GraphComponent, _super);
        function GraphComponent(el, zone, cd, layoutService) {
            var _this = _super.call(this, el, zone, cd) || this;
            _this.el = el;
            _this.zone = zone;
            _this.cd = cd;
            _this.layoutService = layoutService;
            _this.legend = false;
            _this.nodes = [];
            _this.clusters = [];
            _this.links = [];
            _this.activeEntries = [];
            _this.draggingEnabled = true;
            _this.panningEnabled = true;
            _this.panningAxis = PanningAxis.Both;
            _this.enableZoom = true;
            _this.zoomSpeed = 0.1;
            _this.minZoomLevel = 0.1;
            _this.maxZoomLevel = 4.0;
            _this.autoZoom = false;
            _this.panOnZoom = true;
            _this.animate = false;
            _this.autoCenter = false;
            _this.activate = new core.EventEmitter();
            _this.deactivate = new core.EventEmitter();
            _this.zoomChange = new core.EventEmitter();
            _this.clickHandler = new core.EventEmitter();
            _this.isMouseMoveCalled = false;
            _this.graphSubscription = new rxjs.Subscription();
            _this.subscriptions = [];
            _this.margin = [0, 0, 0, 0];
            _this.results = [];
            _this.isPanning = false;
            _this.isDragging = false;
            _this.initialized = false;
            _this.graphDims = { width: 0, height: 0 };
            _this._oldLinks = [];
            _this.oldNodes = new Set();
            _this.transformationMatrix = transformationMatrix.identity();
            _this._touchLastX = null;
            _this._touchLastY = null;
            _this.groupResultsBy = (/**
             * @param {?} node
             * @return {?}
             */
            function (node) { return node.label; });
            return _this;
        }
        Object.defineProperty(GraphComponent.prototype, "zoomLevel", {
            /**
             * Get the current zoom level
             */
            get: /**
             * Get the current zoom level
             * @return {?}
             */
            function () {
                return this.transformationMatrix.a;
            },
            /**
             * Set the current zoom level
             */
            set: /**
             * Set the current zoom level
             * @param {?} level
             * @return {?}
             */
            function (level) {
                this.zoomTo(Number(level));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GraphComponent.prototype, "panOffsetX", {
            /**
             * Get the current `x` position of the graph
             */
            get: /**
             * Get the current `x` position of the graph
             * @return {?}
             */
            function () {
                return this.transformationMatrix.e;
            },
            /**
             * Set the current `x` position of the graph
             */
            set: /**
             * Set the current `x` position of the graph
             * @param {?} x
             * @return {?}
             */
            function (x) {
                this.panTo(Number(x), null);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GraphComponent.prototype, "panOffsetY", {
            /**
             * Get the current `y` position of the graph
             */
            get: /**
             * Get the current `y` position of the graph
             * @return {?}
             */
            function () {
                return this.transformationMatrix.f;
            },
            /**
             * Set the current `y` position of the graph
             */
            set: /**
             * Set the current `y` position of the graph
             * @param {?} y
             * @return {?}
             */
            function (y) {
                this.panTo(null, Number(y));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Angular lifecycle event
         *
         *
         * @memberOf GraphComponent
         */
        /**
         * Angular lifecycle event
         *
         *
         * \@memberOf GraphComponent
         * @return {?}
         */
        GraphComponent.prototype.ngOnInit = /**
         * Angular lifecycle event
         *
         *
         * \@memberOf GraphComponent
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.update$) {
                this.subscriptions.push(this.update$.subscribe((/**
                 * @return {?}
                 */
                function () {
                    _this.update();
                })));
            }
            if (this.center$) {
                this.subscriptions.push(this.center$.subscribe((/**
                 * @return {?}
                 */
                function () {
                    _this.center();
                })));
            }
            if (this.zoomToFit$) {
                this.subscriptions.push(this.zoomToFit$.subscribe((/**
                 * @return {?}
                 */
                function () {
                    _this.zoomToFit();
                })));
            }
            if (this.panToNode$) {
                this.subscriptions.push(this.panToNode$.subscribe((/**
                 * @param {?} nodeId
                 * @return {?}
                 */
                function (nodeId) {
                    _this.panToNodeId(nodeId);
                })));
            }
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        GraphComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            var layout = changes.layout, layoutSettings = changes.layoutSettings, nodes = changes.nodes, clusters = changes.clusters, links = changes.links;
            this.setLayout(this.layout);
            if (layoutSettings) {
                this.setLayoutSettings(this.layoutSettings);
            }
            this.update();
        };
        /**
         * @param {?} layout
         * @return {?}
         */
        GraphComponent.prototype.setLayout = /**
         * @param {?} layout
         * @return {?}
         */
        function (layout) {
            this.initialized = false;
            if (!layout) {
                layout = 'dagre';
            }
            if (typeof layout === 'string') {
                this.layout = this.layoutService.getLayout(layout);
                this.setLayoutSettings(this.layoutSettings);
            }
        };
        /**
         * @param {?} settings
         * @return {?}
         */
        GraphComponent.prototype.setLayoutSettings = /**
         * @param {?} settings
         * @return {?}
         */
        function (settings) {
            if (this.layout && typeof this.layout !== 'string') {
                this.layout.settings = settings;
                this.update();
            }
        };
        /**
         * Angular lifecycle event
         *
         *
         * @memberOf GraphComponent
         */
        /**
         * Angular lifecycle event
         *
         *
         * \@memberOf GraphComponent
         * @return {?}
         */
        GraphComponent.prototype.ngOnDestroy = /**
         * Angular lifecycle event
         *
         *
         * \@memberOf GraphComponent
         * @return {?}
         */
        function () {
            var e_1, _a;
            _super.prototype.ngOnDestroy.call(this);
            try {
                for (var _b = __values(this.subscriptions), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var sub = _c.value;
                    sub.unsubscribe();
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.subscriptions = null;
        };
        /**
         * Angular lifecycle event
         *
         *
         * @memberOf GraphComponent
         */
        /**
         * Angular lifecycle event
         *
         *
         * \@memberOf GraphComponent
         * @return {?}
         */
        GraphComponent.prototype.ngAfterViewInit = /**
         * Angular lifecycle event
         *
         *
         * \@memberOf GraphComponent
         * @return {?}
         */
        function () {
            var _this = this;
            _super.prototype.ngAfterViewInit.call(this);
            setTimeout((/**
             * @return {?}
             */
            function () { return _this.update(); }));
        };
        /**
         * Base class update implementation for the dag graph
         *
         * @memberOf GraphComponent
         */
        /**
         * Base class update implementation for the dag graph
         *
         * \@memberOf GraphComponent
         * @return {?}
         */
        GraphComponent.prototype.update = /**
         * Base class update implementation for the dag graph
         *
         * \@memberOf GraphComponent
         * @return {?}
         */
        function () {
            var _this = this;
            _super.prototype.update.call(this);
            if (!this.curve) {
                this.curve = d3Shape.curveBundle.beta(1);
            }
            this.zone.run((/**
             * @return {?}
             */
            function () {
                _this.dims = ngxCharts.calculateViewDimensions({
                    width: _this.width,
                    height: _this.height,
                    margins: _this.margin,
                    showLegend: _this.legend
                });
                _this.seriesDomain = _this.getSeriesDomain();
                _this.setColors();
                _this.legendOptions = _this.getLegendOptions();
                _this.createGraph();
                _this.updateTransform();
                _this.initialized = true;
            }));
        };
        /**
         * Creates the dagre graph engine
         *
         * @memberOf GraphComponent
         */
        /**
         * Creates the dagre graph engine
         *
         * \@memberOf GraphComponent
         * @return {?}
         */
        GraphComponent.prototype.createGraph = /**
         * Creates the dagre graph engine
         *
         * \@memberOf GraphComponent
         * @return {?}
         */
        function () {
            var _this = this;
            this.graphSubscription.unsubscribe();
            this.graphSubscription = new rxjs.Subscription();
            /** @type {?} */
            var initializeNode = (/**
             * @param {?} n
             * @return {?}
             */
            function (n) {
                if (!n.meta) {
                    n.meta = {};
                }
                if (!n.id) {
                    n.id = id();
                }
                if (!n.dimension) {
                    n.dimension = {
                        width: _this.nodeWidth ? _this.nodeWidth : 30,
                        height: _this.nodeHeight ? _this.nodeHeight : 30
                    };
                    n.meta.forceDimensions = false;
                }
                else {
                    n.meta.forceDimensions = n.meta.forceDimensions === undefined ? true : n.meta.forceDimensions;
                }
                n.position = {
                    x: 0,
                    y: 0
                };
                n.data = n.data ? n.data : {};
                return n;
            });
            this.graph = {
                nodes: __spread(this.nodes).map(initializeNode),
                clusters: __spread((this.clusters || [])).map(initializeNode),
                edges: __spread(this.links).map((/**
                 * @param {?} e
                 * @return {?}
                 */
                function (e) {
                    if (!e.id) {
                        e.id = id();
                    }
                    return e;
                }))
            };
            requestAnimationFrame((/**
             * @return {?}
             */
            function () { return _this.draw(); }));
        };
        /**
         * Draws the graph using dagre layouts
         *
         *
         * @memberOf GraphComponent
         */
        /**
         * Draws the graph using dagre layouts
         *
         *
         * \@memberOf GraphComponent
         * @return {?}
         */
        GraphComponent.prototype.draw = /**
         * Draws the graph using dagre layouts
         *
         *
         * \@memberOf GraphComponent
         * @return {?}
         */
        function () {
            var _this = this;
            if (!this.layout || typeof this.layout === 'string') {
                return;
            }
            // Calc view dims for the nodes
            this.applyNodeDimensions();
            // Recalc the layout
            /** @type {?} */
            var result = this.layout.run(this.graph);
            /** @type {?} */
            var result$ = result instanceof rxjs.Observable ? result : rxjs.of(result);
            this.graphSubscription.add(result$.subscribe((/**
             * @param {?} graph
             * @return {?}
             */
            function (graph) {
                _this.graph = graph;
                _this.tick();
            })));
            result$.pipe(operators.first((/**
             * @param {?} graph
             * @return {?}
             */
            function (graph) { return graph.nodes.length > 0; }))).subscribe((/**
             * @return {?}
             */
            function () { return _this.applyNodeDimensions(); }));
        };
        /**
         * @return {?}
         */
        GraphComponent.prototype.tick = /**
         * @return {?}
         */
        function () {
            var _this = this;
            // Transposes view options to the node
            /** @type {?} */
            var oldNodes = new Set();
            this.graph.nodes.map((/**
             * @param {?} n
             * @return {?}
             */
            function (n) {
                n.transform = "translate(" + (n.position.x - n.dimension.width / 2 || 0) + ", " + (n.position.y - n.dimension.height / 2 ||
                    0) + ")";
                if (!n.data) {
                    n.data = {};
                }
                n.data.color = _this.colors.getColor(_this.groupResultsBy(n));
                oldNodes.add(n.id);
            }));
            // Prevent animations on new nodes
            setTimeout((/**
             * @return {?}
             */
            function () {
                _this.oldNodes = oldNodes;
            }), 500);
            (this.graph.clusters || []).map((/**
             * @param {?} n
             * @return {?}
             */
            function (n) {
                n.transform = "translate(" + (n.position.x - n.dimension.width / 2 || 0) + ", " + (n.position.y - n.dimension.height / 2 ||
                    0) + ")";
                if (!n.data) {
                    n.data = {};
                }
                n.data.color = _this.colors.getColor(_this.groupResultsBy(n));
            }));
            // Update the labels to the new positions
            /** @type {?} */
            var newLinks = [];
            var _loop_1 = function (edgeLabelId) {
                /** @type {?} */
                var edgeLabel = this_1.graph.edgeLabels[edgeLabelId];
                /** @type {?} */
                var normKey = edgeLabelId.replace(/[^\w-]*/g, '');
                /** @type {?} */
                var isMultigraph = this_1.layout && typeof this_1.layout !== 'string' && this_1.layout.settings && this_1.layout.settings.multigraph;
                /** @type {?} */
                var oldLink = isMultigraph ? this_1._oldLinks.find((/**
                 * @param {?} ol
                 * @return {?}
                 */
                function (ol) { return "" + ol.source + ol.target + ol.id === normKey; })) :
                    this_1._oldLinks.find((/**
                     * @param {?} ol
                     * @return {?}
                     */
                    function (ol) { return "" + ol.source + ol.target === normKey; }));
                /** @type {?} */
                var linkFromGraph = isMultigraph ? this_1.graph.edges.find((/**
                 * @param {?} nl
                 * @return {?}
                 */
                function (nl) { return "" + nl.source + nl.target + nl.id === normKey; })) :
                    this_1.graph.edges.find((/**
                     * @param {?} nl
                     * @return {?}
                     */
                    function (nl) { return "" + nl.source + nl.target === normKey; }));
                if (!oldLink) {
                    oldLink = linkFromGraph || edgeLabel;
                }
                else if (oldLink.data &&
                    linkFromGraph && linkFromGraph.data &&
                    JSON.stringify(oldLink.data) !== JSON.stringify(linkFromGraph.data)) { // Compare old link to new link and replace if not equal      
                    oldLink.data = linkFromGraph.data;
                }
                oldLink.oldLine = oldLink.line;
                /** @type {?} */
                var points = edgeLabel.points;
                /** @type {?} */
                var line = this_1.generateLine(points);
                /** @type {?} */
                var newLink = Object.assign({}, oldLink);
                newLink.line = line;
                newLink.points = points;
                this_1.updateMidpointOnEdge(newLink, points);
                /** @type {?} */
                var textPos = points[Math.floor(points.length / 2)];
                if (textPos) {
                    newLink.textTransform = "translate(" + (textPos.x || 0) + "," + (textPos.y || 0) + ")";
                }
                newLink.textAngle = 0;
                if (!newLink.oldLine) {
                    newLink.oldLine = newLink.line;
                }
                this_1.calcDominantBaseline(newLink);
                newLinks.push(newLink);
            };
            var this_1 = this;
            for (var edgeLabelId in this.graph.edgeLabels) {
                _loop_1(edgeLabelId);
            }
            this.graph.edges = newLinks;
            // Map the old links for animations
            if (this.graph.edges) {
                this._oldLinks = this.graph.edges.map((/**
                 * @param {?} l
                 * @return {?}
                 */
                function (l) {
                    /** @type {?} */
                    var newL = Object.assign({}, l);
                    newL.oldLine = l.line;
                    return newL;
                }));
            }
            // Calculate the height/width total, but only if we have any nodes
            if (this.graph.nodes && this.graph.nodes.length) {
                this.graphDims.width = Math.max.apply(Math, __spread(this.graph.nodes.map((/**
                 * @param {?} n
                 * @return {?}
                 */
                function (n) { return n.position.x + n.dimension.width; }))));
                this.graphDims.height = Math.max.apply(Math, __spread(this.graph.nodes.map((/**
                 * @param {?} n
                 * @return {?}
                 */
                function (n) { return n.position.y + n.dimension.height; }))));
            }
            if (this.autoZoom) {
                this.zoomToFit();
            }
            if (this.autoCenter) {
                // Auto-center when rendering
                this.center();
            }
            requestAnimationFrame((/**
             * @return {?}
             */
            function () { return _this.redrawLines(); }));
            this.cd.markForCheck();
        };
        /**
         * Measures the node element and applies the dimensions
         *
         * @memberOf GraphComponent
         */
        /**
         * Measures the node element and applies the dimensions
         *
         * \@memberOf GraphComponent
         * @return {?}
         */
        GraphComponent.prototype.applyNodeDimensions = /**
         * Measures the node element and applies the dimensions
         *
         * \@memberOf GraphComponent
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.nodeElements && this.nodeElements.length) {
                this.nodeElements.map((/**
                 * @param {?} elem
                 * @return {?}
                 */
                function (elem) {
                    var e_2, _a;
                    /** @type {?} */
                    var nativeElement = elem.nativeElement;
                    /** @type {?} */
                    var node = _this.graph.nodes.find((/**
                     * @param {?} n
                     * @return {?}
                     */
                    function (n) { return n.id === nativeElement.id; }));
                    // calculate the height
                    /** @type {?} */
                    var dims;
                    try {
                        dims = nativeElement.getBBox();
                    }
                    catch (ex) {
                        // Skip drawing if element is not displayed - Firefox would throw an error here
                        return;
                    }
                    if (_this.nodeHeight) {
                        node.dimension.height = node.dimension.height && node.meta.forceDimensions ? node.dimension.height : _this.nodeHeight;
                    }
                    else {
                        node.dimension.height = node.dimension.height && node.meta.forceDimensions ? node.dimension.height : dims.height;
                    }
                    if (_this.nodeMaxHeight) {
                        node.dimension.height = Math.max(node.dimension.height, _this.nodeMaxHeight);
                    }
                    if (_this.nodeMinHeight) {
                        node.dimension.height = Math.min(node.dimension.height, _this.nodeMinHeight);
                    }
                    if (_this.nodeWidth) {
                        node.dimension.width = node.dimension.width && node.meta.forceDimensions ? node.dimension.width : _this.nodeWidth;
                    }
                    else {
                        // calculate the width
                        if (nativeElement.getElementsByTagName('text').length) {
                            /** @type {?} */
                            var maxTextDims = void 0;
                            try {
                                try {
                                    for (var _b = __values(nativeElement.getElementsByTagName('text')), _c = _b.next(); !_c.done; _c = _b.next()) {
                                        var textElem = _c.value;
                                        /** @type {?} */
                                        var currentBBox = textElem.getBBox();
                                        if (!maxTextDims) {
                                            maxTextDims = currentBBox;
                                        }
                                        else {
                                            if (currentBBox.width > maxTextDims.width) {
                                                maxTextDims.width = currentBBox.width;
                                            }
                                            if (currentBBox.height > maxTextDims.height) {
                                                maxTextDims.height = currentBBox.height;
                                            }
                                        }
                                    }
                                }
                                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                                finally {
                                    try {
                                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                                    }
                                    finally { if (e_2) throw e_2.error; }
                                }
                            }
                            catch (ex) {
                                // Skip drawing if element is not displayed - Firefox would throw an error here
                                return;
                            }
                            node.dimension.width = node.dimension.width && node.meta.forceDimensions ? node.dimension.width : maxTextDims.width + 20;
                        }
                        else {
                            node.dimension.width = node.dimension.width && node.meta.forceDimensions ? node.dimension.width : dims.width;
                        }
                    }
                    if (_this.nodeMaxWidth) {
                        node.dimension.width = Math.max(node.dimension.width, _this.nodeMaxWidth);
                    }
                    if (_this.nodeMinWidth) {
                        node.dimension.width = Math.min(node.dimension.width, _this.nodeMinWidth);
                    }
                }));
            }
        };
        /**
         * Redraws the lines when dragged or viewport updated
         *
         * @memberOf GraphComponent
         */
        /**
         * Redraws the lines when dragged or viewport updated
         *
         * \@memberOf GraphComponent
         * @param {?=} _animate
         * @return {?}
         */
        GraphComponent.prototype.redrawLines = /**
         * Redraws the lines when dragged or viewport updated
         *
         * \@memberOf GraphComponent
         * @param {?=} _animate
         * @return {?}
         */
        function (_animate) {
            var _this = this;
            if (_animate === void 0) { _animate = this.animate; }
            this.linkElements.map((/**
             * @param {?} linkEl
             * @return {?}
             */
            function (linkEl) {
                /** @type {?} */
                var edge = _this.graph.edges.find((/**
                 * @param {?} lin
                 * @return {?}
                 */
                function (lin) { return lin.id === linkEl.nativeElement.id; }));
                if (edge) {
                    /** @type {?} */
                    var linkSelection = d3Selection.select(linkEl.nativeElement).select('.line');
                    linkSelection
                        .attr('d', edge.oldLine)
                        .transition()
                        .ease(d3Ease.easeSinInOut)
                        .duration(_animate ? 500 : 0)
                        .attr('d', edge.line);
                    /** @type {?} */
                    var textPathSelection = d3Selection.select(_this.chartElement.nativeElement).select("#" + edge.id);
                    textPathSelection
                        .attr('d', edge.oldTextPath)
                        .transition()
                        .ease(d3Ease.easeSinInOut)
                        .duration(_animate ? 500 : 0)
                        .attr('d', edge.textPath);
                    _this.updateMidpointOnEdge(edge, edge.points);
                }
            }));
        };
        /**
         * Calculate the text directions / flipping
         *
         * @memberOf GraphComponent
         */
        /**
         * Calculate the text directions / flipping
         *
         * \@memberOf GraphComponent
         * @param {?} link
         * @return {?}
         */
        GraphComponent.prototype.calcDominantBaseline = /**
         * Calculate the text directions / flipping
         *
         * \@memberOf GraphComponent
         * @param {?} link
         * @return {?}
         */
        function (link) {
            /** @type {?} */
            var firstPoint = link.points[0];
            /** @type {?} */
            var lastPoint = link.points[link.points.length - 1];
            link.oldTextPath = link.textPath;
            if (lastPoint.x < firstPoint.x) {
                link.dominantBaseline = 'text-before-edge';
                // reverse text path for when its flipped upside down
                link.textPath = this.generateLine(__spread(link.points).reverse());
            }
            else {
                link.dominantBaseline = 'text-after-edge';
                link.textPath = link.line;
            }
        };
        /**
         * Generate the new line path
         *
         * @memberOf GraphComponent
         */
        /**
         * Generate the new line path
         *
         * \@memberOf GraphComponent
         * @param {?} points
         * @return {?}
         */
        GraphComponent.prototype.generateLine = /**
         * Generate the new line path
         *
         * \@memberOf GraphComponent
         * @param {?} points
         * @return {?}
         */
        function (points) {
            /** @type {?} */
            var lineFunction = d3Shape.line()
                .x((/**
             * @param {?} d
             * @return {?}
             */
            function (d) { return d.x; }))
                .y((/**
             * @param {?} d
             * @return {?}
             */
            function (d) { return d.y; }))
                .curve(this.curve);
            return lineFunction(points);
        };
        /**
         * Zoom was invoked from event
         *
         * @memberOf GraphComponent
         */
        /**
         * Zoom was invoked from event
         *
         * \@memberOf GraphComponent
         * @param {?} $event
         * @param {?} direction
         * @return {?}
         */
        GraphComponent.prototype.onZoom = /**
         * Zoom was invoked from event
         *
         * \@memberOf GraphComponent
         * @param {?} $event
         * @param {?} direction
         * @return {?}
         */
        function ($event, direction) {
            /** @type {?} */
            var zoomFactor = 1 + (direction === 'in' ? this.zoomSpeed : -this.zoomSpeed);
            // Check that zooming wouldn't put us out of bounds
            /** @type {?} */
            var newZoomLevel = this.zoomLevel * zoomFactor;
            if (newZoomLevel <= this.minZoomLevel || newZoomLevel >= this.maxZoomLevel) {
                return;
            }
            // Check if zooming is enabled or not
            if (!this.enableZoom) {
                return;
            }
            if (this.panOnZoom === true && $event) {
                // Absolute mouse X/Y on the screen
                /** @type {?} */
                var mouseX = $event.clientX;
                /** @type {?} */
                var mouseY = $event.clientY;
                // Transform the mouse X/Y into a SVG X/Y
                /** @type {?} */
                var svg = this.chart.nativeElement.querySelector('svg');
                /** @type {?} */
                var svgGroup = svg.querySelector('g.chart');
                /** @type {?} */
                var point = svg.createSVGPoint();
                point.x = mouseX;
                point.y = mouseY;
                /** @type {?} */
                var svgPoint = point.matrixTransform(svgGroup.getScreenCTM().inverse());
                // Panzoom
                this.pan(svgPoint.x, svgPoint.y, true);
                this.zoom(zoomFactor);
                this.pan(-svgPoint.x, -svgPoint.y, true);
            }
            else {
                this.zoom(zoomFactor);
            }
        };
        /**
         * Pan by x/y
         *
         * @param x
         * @param y
         */
        /**
         * Pan by x/y
         *
         * @param {?} x
         * @param {?} y
         * @param {?=} ignoreZoomLevel
         * @return {?}
         */
        GraphComponent.prototype.pan = /**
         * Pan by x/y
         *
         * @param {?} x
         * @param {?} y
         * @param {?=} ignoreZoomLevel
         * @return {?}
         */
        function (x, y, ignoreZoomLevel) {
            if (ignoreZoomLevel === void 0) { ignoreZoomLevel = false; }
            /** @type {?} */
            var zoomLevel = ignoreZoomLevel ? 1 : this.zoomLevel;
            this.transformationMatrix = transformationMatrix.transform(this.transformationMatrix, transformationMatrix.translate(x / zoomLevel, y / zoomLevel));
            this.updateTransform();
        };
        /**
         * Pan to a fixed x/y
         *
         */
        /**
         * Pan to a fixed x/y
         *
         * @param {?} x
         * @param {?} y
         * @return {?}
         */
        GraphComponent.prototype.panTo = /**
         * Pan to a fixed x/y
         *
         * @param {?} x
         * @param {?} y
         * @return {?}
         */
        function (x, y) {
            if (x === null || x === undefined || isNaN(x) || y === null || y === undefined || isNaN(y)) {
                return;
            }
            /** @type {?} */
            var panX = -this.panOffsetX - x * this.zoomLevel + this.dims.width / 2;
            /** @type {?} */
            var panY = -this.panOffsetY - y * this.zoomLevel + this.dims.height / 2;
            this.transformationMatrix = transformationMatrix.transform(this.transformationMatrix, transformationMatrix.translate(panX / this.zoomLevel, panY / this.zoomLevel));
            this.updateTransform();
        };
        /**
         * Zoom by a factor
         *
         */
        /**
         * Zoom by a factor
         *
         * @param {?} factor
         * @return {?}
         */
        GraphComponent.prototype.zoom = /**
         * Zoom by a factor
         *
         * @param {?} factor
         * @return {?}
         */
        function (factor) {
            this.transformationMatrix = transformationMatrix.transform(this.transformationMatrix, transformationMatrix.scale(factor, factor));
            this.zoomChange.emit(this.zoomLevel);
            this.updateTransform();
        };
        /**
         * Zoom to a fixed level
         *
         */
        /**
         * Zoom to a fixed level
         *
         * @param {?} level
         * @return {?}
         */
        GraphComponent.prototype.zoomTo = /**
         * Zoom to a fixed level
         *
         * @param {?} level
         * @return {?}
         */
        function (level) {
            this.transformationMatrix.a = isNaN(level) ? this.transformationMatrix.a : Number(level);
            this.transformationMatrix.d = isNaN(level) ? this.transformationMatrix.d : Number(level);
            this.zoomChange.emit(this.zoomLevel);
            this.updateTransform();
            this.update();
        };
        /**
         * Pan was invoked from event
         *
         * @memberOf GraphComponent
         */
        /**
         * Pan was invoked from event
         *
         * \@memberOf GraphComponent
         * @param {?} event
         * @return {?}
         */
        GraphComponent.prototype.onPan = /**
         * Pan was invoked from event
         *
         * \@memberOf GraphComponent
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.pan(event.movementX, event.movementY);
        };
        /**
         * Drag was invoked from an event
         *
         * @memberOf GraphComponent
         */
        /**
         * Drag was invoked from an event
         *
         * \@memberOf GraphComponent
         * @param {?} event
         * @return {?}
         */
        GraphComponent.prototype.onDrag = /**
         * Drag was invoked from an event
         *
         * \@memberOf GraphComponent
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var _this = this;
            var e_3, _a;
            if (!this.draggingEnabled) {
                return;
            }
            /** @type {?} */
            var node = this.draggingNode;
            if (this.layout && typeof this.layout !== 'string' && this.layout.onDrag) {
                this.layout.onDrag(node, event);
            }
            node.position.x += event.movementX / this.zoomLevel;
            node.position.y += event.movementY / this.zoomLevel;
            // move the node
            /** @type {?} */
            var x = node.position.x - node.dimension.width / 2;
            /** @type {?} */
            var y = node.position.y - node.dimension.height / 2;
            node.transform = "translate(" + x + ", " + y + ")";
            var _loop_2 = function (link) {
                if (link.target === node.id ||
                    link.source === node.id ||
                    ((/** @type {?} */ (link.target))).id === node.id ||
                    ((/** @type {?} */ (link.source))).id === node.id) {
                    if (this_2.layout && typeof this_2.layout !== 'string') {
                        /** @type {?} */
                        var result = this_2.layout.updateEdge(this_2.graph, link);
                        /** @type {?} */
                        var result$ = result instanceof rxjs.Observable ? result : rxjs.of(result);
                        this_2.graphSubscription.add(result$.subscribe((/**
                         * @param {?} graph
                         * @return {?}
                         */
                        function (graph) {
                            _this.graph = graph;
                            _this.redrawEdge(link);
                        })));
                    }
                }
            };
            var this_2 = this;
            try {
                for (var _b = __values(this.graph.edges), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var link = _c.value;
                    _loop_2(link);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            this.redrawLines(false);
        };
        /**
         * @param {?} edge
         * @return {?}
         */
        GraphComponent.prototype.redrawEdge = /**
         * @param {?} edge
         * @return {?}
         */
        function (edge) {
            /** @type {?} */
            var line = this.generateLine(edge.points);
            this.calcDominantBaseline(edge);
            edge.oldLine = edge.line;
            edge.line = line;
        };
        /**
         * Update the entire view for the new pan position
         *
         *
         * @memberOf GraphComponent
         */
        /**
         * Update the entire view for the new pan position
         *
         *
         * \@memberOf GraphComponent
         * @return {?}
         */
        GraphComponent.prototype.updateTransform = /**
         * Update the entire view for the new pan position
         *
         *
         * \@memberOf GraphComponent
         * @return {?}
         */
        function () {
            this.transform = transformationMatrix.toSVG(transformationMatrix.smoothMatrix(this.transformationMatrix, 100));
        };
        /**
         * Node was clicked
         *
         *
         * @memberOf GraphComponent
         */
        /**
         * Node was clicked
         *
         *
         * \@memberOf GraphComponent
         * @param {?} event
         * @return {?}
         */
        GraphComponent.prototype.onClick = /**
         * Node was clicked
         *
         *
         * \@memberOf GraphComponent
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.select.emit(event);
        };
        /**
         * Node was focused
         *
         *
         * @memberOf GraphComponent
         */
        /**
         * Node was focused
         *
         *
         * \@memberOf GraphComponent
         * @param {?} event
         * @return {?}
         */
        GraphComponent.prototype.onActivate = /**
         * Node was focused
         *
         *
         * \@memberOf GraphComponent
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.activeEntries.indexOf(event) > -1) {
                return;
            }
            this.activeEntries = __spread([event], this.activeEntries);
            this.activate.emit({ value: event, entries: this.activeEntries });
        };
        /**
         * Node was defocused
         *
         * @memberOf GraphComponent
         */
        /**
         * Node was defocused
         *
         * \@memberOf GraphComponent
         * @param {?} event
         * @return {?}
         */
        GraphComponent.prototype.onDeactivate = /**
         * Node was defocused
         *
         * \@memberOf GraphComponent
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /** @type {?} */
            var idx = this.activeEntries.indexOf(event);
            this.activeEntries.splice(idx, 1);
            this.activeEntries = __spread(this.activeEntries);
            this.deactivate.emit({ value: event, entries: this.activeEntries });
        };
        /**
         * Get the domain series for the nodes
         *
         * @memberOf GraphComponent
         */
        /**
         * Get the domain series for the nodes
         *
         * \@memberOf GraphComponent
         * @return {?}
         */
        GraphComponent.prototype.getSeriesDomain = /**
         * Get the domain series for the nodes
         *
         * \@memberOf GraphComponent
         * @return {?}
         */
        function () {
            var _this = this;
            return this.nodes
                .map((/**
             * @param {?} d
             * @return {?}
             */
            function (d) { return _this.groupResultsBy(d); }))
                .reduce((/**
             * @param {?} nodes
             * @param {?} node
             * @return {?}
             */
            function (nodes, node) { return (nodes.indexOf(node) !== -1 ? nodes : nodes.concat([node])); }), [])
                .sort();
        };
        /**
         * Tracking for the link
         *
         *
         * @memberOf GraphComponent
         */
        /**
         * Tracking for the link
         *
         *
         * \@memberOf GraphComponent
         * @param {?} index
         * @param {?} link
         * @return {?}
         */
        GraphComponent.prototype.trackLinkBy = /**
         * Tracking for the link
         *
         *
         * \@memberOf GraphComponent
         * @param {?} index
         * @param {?} link
         * @return {?}
         */
        function (index, link) {
            return link.id;
        };
        /**
         * Tracking for the node
         *
         *
         * @memberOf GraphComponent
         */
        /**
         * Tracking for the node
         *
         *
         * \@memberOf GraphComponent
         * @param {?} index
         * @param {?} node
         * @return {?}
         */
        GraphComponent.prototype.trackNodeBy = /**
         * Tracking for the node
         *
         *
         * \@memberOf GraphComponent
         * @param {?} index
         * @param {?} node
         * @return {?}
         */
        function (index, node) {
            return node.id;
        };
        /**
         * Sets the colors the nodes
         *
         *
         * @memberOf GraphComponent
         */
        /**
         * Sets the colors the nodes
         *
         *
         * \@memberOf GraphComponent
         * @return {?}
         */
        GraphComponent.prototype.setColors = /**
         * Sets the colors the nodes
         *
         *
         * \@memberOf GraphComponent
         * @return {?}
         */
        function () {
            this.colors = new ngxCharts.ColorHelper(this.scheme, 'ordinal', this.seriesDomain, this.customColors);
        };
        /**
         * Gets the legend options
         *
         * @memberOf GraphComponent
         */
        /**
         * Gets the legend options
         *
         * \@memberOf GraphComponent
         * @return {?}
         */
        GraphComponent.prototype.getLegendOptions = /**
         * Gets the legend options
         *
         * \@memberOf GraphComponent
         * @return {?}
         */
        function () {
            return {
                scaleType: 'ordinal',
                domain: this.seriesDomain,
                colors: this.colors
            };
        };
        /**
         * On mouse move event, used for panning and dragging.
         *
         * @memberOf GraphComponent
         */
        /**
         * On mouse move event, used for panning and dragging.
         *
         * \@memberOf GraphComponent
         * @param {?} $event
         * @return {?}
         */
        GraphComponent.prototype.onMouseMove = /**
         * On mouse move event, used for panning and dragging.
         *
         * \@memberOf GraphComponent
         * @param {?} $event
         * @return {?}
         */
        function ($event) {
            this.isMouseMoveCalled = true;
            if (this.isPanning && this.panningEnabled) {
                this.checkEnum(this.panningAxis, $event);
            }
            else if (this.isDragging && this.draggingEnabled) {
                this.onDrag($event);
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        GraphComponent.prototype.onMouseDown = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.isMouseMoveCalled = false;
        };
        /**
         * @param {?} event
         * @return {?}
         */
        GraphComponent.prototype.graphClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (!this.isMouseMoveCalled)
                this.clickHandler.emit(event);
        };
        /**
         * On touch start event to enable panning.
         *
         * @memberOf GraphComponent
         */
        /**
         * On touch start event to enable panning.
         *
         * \@memberOf GraphComponent
         * @param {?} event
         * @return {?}
         */
        GraphComponent.prototype.onTouchStart = /**
         * On touch start event to enable panning.
         *
         * \@memberOf GraphComponent
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this._touchLastX = event.changedTouches[0].clientX;
            this._touchLastY = event.changedTouches[0].clientY;
            this.isPanning = true;
        };
        /**
         * On touch move event, used for panning.
         *
         */
        /**
         * On touch move event, used for panning.
         *
         * @param {?} $event
         * @return {?}
         */
        GraphComponent.prototype.onTouchMove = /**
         * On touch move event, used for panning.
         *
         * @param {?} $event
         * @return {?}
         */
        function ($event) {
            if (this.isPanning && this.panningEnabled) {
                /** @type {?} */
                var clientX = $event.changedTouches[0].clientX;
                /** @type {?} */
                var clientY = $event.changedTouches[0].clientY;
                /** @type {?} */
                var movementX = clientX - this._touchLastX;
                /** @type {?} */
                var movementY = clientY - this._touchLastY;
                this._touchLastX = clientX;
                this._touchLastY = clientY;
                this.pan(movementX, movementY);
            }
        };
        /**
         * On touch end event to disable panning.
         *
         * @memberOf GraphComponent
         */
        /**
         * On touch end event to disable panning.
         *
         * \@memberOf GraphComponent
         * @param {?} event
         * @return {?}
         */
        GraphComponent.prototype.onTouchEnd = /**
         * On touch end event to disable panning.
         *
         * \@memberOf GraphComponent
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.isPanning = false;
        };
        /**
         * On mouse up event to disable panning/dragging.
         *
         * @memberOf GraphComponent
         */
        /**
         * On mouse up event to disable panning/dragging.
         *
         * \@memberOf GraphComponent
         * @param {?} event
         * @return {?}
         */
        GraphComponent.prototype.onMouseUp = /**
         * On mouse up event to disable panning/dragging.
         *
         * \@memberOf GraphComponent
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.isDragging = false;
            this.isPanning = false;
            if (this.layout && typeof this.layout !== 'string' && this.layout.onDragEnd) {
                this.layout.onDragEnd(this.draggingNode, event);
            }
        };
        /**
         * On node mouse down to kick off dragging
         *
         * @memberOf GraphComponent
         */
        /**
         * On node mouse down to kick off dragging
         *
         * \@memberOf GraphComponent
         * @param {?} event
         * @param {?} node
         * @return {?}
         */
        GraphComponent.prototype.onNodeMouseDown = /**
         * On node mouse down to kick off dragging
         *
         * \@memberOf GraphComponent
         * @param {?} event
         * @param {?} node
         * @return {?}
         */
        function (event, node) {
            if (!this.draggingEnabled) {
                return;
            }
            this.isDragging = true;
            this.draggingNode = node;
            if (this.layout && typeof this.layout !== 'string' && this.layout.onDragStart) {
                this.layout.onDragStart(node, event);
            }
        };
        /**
         * Center the graph in the viewport
         */
        /**
         * Center the graph in the viewport
         * @return {?}
         */
        GraphComponent.prototype.center = /**
         * Center the graph in the viewport
         * @return {?}
         */
        function () {
            this.panTo(this.graphDims.width / 2, this.graphDims.height / 2);
        };
        /**
         * Zooms to fit the entier graph
         */
        /**
         * Zooms to fit the entier graph
         * @return {?}
         */
        GraphComponent.prototype.zoomToFit = /**
         * Zooms to fit the entier graph
         * @return {?}
         */
        function () {
            /** @type {?} */
            var heightZoom = this.dims.height / this.graphDims.height;
            /** @type {?} */
            var widthZoom = this.dims.width / this.graphDims.width;
            /** @type {?} */
            var zoomLevel = Math.min(heightZoom, widthZoom, 1);
            if (zoomLevel <= this.minZoomLevel || zoomLevel >= this.maxZoomLevel) {
                return;
            }
            if (zoomLevel !== this.zoomLevel) {
                this.zoomLevel = zoomLevel;
                this.updateTransform();
                this.zoomChange.emit(this.zoomLevel);
            }
        };
        /**
         * Pans to the node
         * @param nodeId
         */
        /**
         * Pans to the node
         * @param {?} nodeId
         * @return {?}
         */
        GraphComponent.prototype.panToNodeId = /**
         * Pans to the node
         * @param {?} nodeId
         * @return {?}
         */
        function (nodeId) {
            /** @type {?} */
            var node = this.nodes.find((/**
             * @param {?} n
             * @return {?}
             */
            function (n) { return n.id === nodeId; }));
            if (!node) {
                return;
            }
            this.panTo(node.position.x, node.position.y);
        };
        /**
         * @private
         * @param {?} key
         * @param {?} event
         * @return {?}
         */
        GraphComponent.prototype.checkEnum = /**
         * @private
         * @param {?} key
         * @param {?} event
         * @return {?}
         */
        function (key, event) {
            switch (key) {
                case PanningAxis.Horizontal:
                    this.pan(event.movementX, 0);
                    break;
                case PanningAxis.Vertical:
                    this.pan(0, event.movementY);
                    break;
                default:
                    this.onPan(event);
                    break;
            }
        };
        /**
         * @private
         * @param {?} edge
         * @param {?} points
         * @return {?}
         */
        GraphComponent.prototype.updateMidpointOnEdge = /**
         * @private
         * @param {?} edge
         * @param {?} points
         * @return {?}
         */
        function (edge, points) {
            if (!edge || !points) {
                return;
            }
            if (points.length % 2 === 1) {
                edge.midPoint = points[Math.floor(points.length / 2)];
            }
            else {
                /** @type {?} */
                var first_1 = points[points.length / 2];
                /** @type {?} */
                var second = points[points.length / 2 - 1];
                edge.midPoint = {
                    x: (first_1.x + second.x) / 2,
                    y: (first_1.y + second.y) / 2
                };
            }
        };
        GraphComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ngx-graph',
                        template: "<ngx-charts-chart\n  [view]=\"[width, height]\"\n  [showLegend]=\"legend\"\n  [legendOptions]=\"legendOptions\"\n  (legendLabelClick)=\"onClick($event)\"\n  (legendLabelActivate)=\"onActivate($event)\"\n  (legendLabelDeactivate)=\"onDeactivate($event)\"\n  mouseWheel\n  (mouseWheelUp)=\"onZoom($event, 'in')\"\n  (mouseWheelDown)=\"onZoom($event, 'out')\"\n>\n  <svg:g\n    *ngIf=\"initialized && graph\"\n    [attr.transform]=\"transform\"\n    (touchstart)=\"onTouchStart($event)\"\n    (touchend)=\"onTouchEnd($event)\"\n    class=\"graph chart\"\n  >\n    <defs>\n      <ng-template *ngIf=\"defsTemplate\" [ngTemplateOutlet]=\"defsTemplate\"></ng-template>\n      <svg:path\n        class=\"text-path\"\n        *ngFor=\"let link of graph.edges\"\n        [attr.d]=\"link.textPath\"\n        [attr.id]=\"link.id\"\n      ></svg:path>\n    </defs>\n\n    <svg:rect\n      class=\"panning-rect\"\n      [attr.width]=\"dims.width * 100\"\n      [attr.height]=\"dims.height * 100\"\n      [attr.transform]=\"'translate(' + (-dims.width || 0) * 50 + ',' + (-dims.height || 0) * 50 + ')'\"\n      (mousedown)=\"isPanning = true\"\n    />\n\n    <ng-content></ng-content>\n\n    <svg:g class=\"clusters\">\n      <svg:g\n        #clusterElement\n        *ngFor=\"let node of graph.clusters; trackBy: trackNodeBy\"\n        class=\"node-group\"\n        [id]=\"node.id\"\n        [attr.transform]=\"node.transform\"\n        (click)=\"onClick(node)\"\n      >\n        <ng-template\n          *ngIf=\"clusterTemplate\"\n          [ngTemplateOutlet]=\"clusterTemplate\"\n          [ngTemplateOutletContext]=\"{ $implicit: node }\"\n        ></ng-template>\n        <svg:g *ngIf=\"!clusterTemplate\" class=\"node cluster\">\n          <svg:rect\n            [attr.width]=\"node.dimension.width\"\n            [attr.height]=\"node.dimension.height\"\n            [attr.fill]=\"node.data?.color\"\n          />\n          <svg:text alignment-baseline=\"central\" [attr.x]=\"10\" [attr.y]=\"node.dimension.height / 2\">\n            {{ node.label }}\n          </svg:text>\n        </svg:g>\n      </svg:g>\n    </svg:g>\n\n    <svg:g class=\"links\">\n      <svg:g #linkElement *ngFor=\"let link of graph.edges; trackBy: trackLinkBy\" class=\"link-group\" [id]=\"link.id\">\n        <ng-template\n          *ngIf=\"linkTemplate\"\n          [ngTemplateOutlet]=\"linkTemplate\"\n          [ngTemplateOutletContext]=\"{ $implicit: link }\"\n        ></ng-template>\n        <svg:path *ngIf=\"!linkTemplate\" class=\"edge\" [attr.d]=\"link.line\" />\n      </svg:g>\n    </svg:g>\n\n    <svg:g class=\"nodes\">\n      <svg:g\n        #nodeElement\n        *ngFor=\"let node of graph.nodes; trackBy: trackNodeBy\"\n        class=\"node-group\"\n        [class.old-node]=\"animate && oldNodes.has(node.id)\"\n        [id]=\"node.id\"\n        [attr.transform]=\"node.transform\"\n        (click)=\"onClick(node)\"\n        (mousedown)=\"onNodeMouseDown($event, node)\"\n      >\n        <ng-template\n          *ngIf=\"nodeTemplate\"\n          [ngTemplateOutlet]=\"nodeTemplate\"\n          [ngTemplateOutletContext]=\"{ $implicit: node }\"\n        ></ng-template>\n        <svg:circle\n          *ngIf=\"!nodeTemplate\"\n          r=\"10\"\n          [attr.cx]=\"node.dimension.width / 2\"\n          [attr.cy]=\"node.dimension.height / 2\"\n          [attr.fill]=\"node.data?.color\"\n        />\n      </svg:g>\n    </svg:g>\n  </svg:g>\n</ngx-charts-chart>\n",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [".graph{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.graph .edge{stroke:#666;fill:none}.graph .edge .edge-label{stroke:none;font-size:12px;fill:#251e1e}.graph .panning-rect{fill:transparent;cursor:move}.graph .node-group.old-node{transition:transform .5s ease-in-out;transition:transform .5s ease-in-out,-webkit-transform .5s ease-in-out}.graph .node-group .node:focus{outline:0}.graph .cluster rect{opacity:.2}"]
                    }] }
        ];
        /** @nocollapse */
        GraphComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.NgZone },
            { type: core.ChangeDetectorRef },
            { type: LayoutService }
        ]; };
        GraphComponent.propDecorators = {
            legend: [{ type: core.Input }],
            nodes: [{ type: core.Input }],
            clusters: [{ type: core.Input }],
            links: [{ type: core.Input }],
            activeEntries: [{ type: core.Input }],
            curve: [{ type: core.Input }],
            draggingEnabled: [{ type: core.Input }],
            nodeHeight: [{ type: core.Input }],
            nodeMaxHeight: [{ type: core.Input }],
            nodeMinHeight: [{ type: core.Input }],
            nodeWidth: [{ type: core.Input }],
            nodeMinWidth: [{ type: core.Input }],
            nodeMaxWidth: [{ type: core.Input }],
            panningEnabled: [{ type: core.Input }],
            panningAxis: [{ type: core.Input }],
            enableZoom: [{ type: core.Input }],
            zoomSpeed: [{ type: core.Input }],
            minZoomLevel: [{ type: core.Input }],
            maxZoomLevel: [{ type: core.Input }],
            autoZoom: [{ type: core.Input }],
            panOnZoom: [{ type: core.Input }],
            animate: [{ type: core.Input }],
            autoCenter: [{ type: core.Input }],
            update$: [{ type: core.Input }],
            center$: [{ type: core.Input }],
            zoomToFit$: [{ type: core.Input }],
            panToNode$: [{ type: core.Input }],
            layout: [{ type: core.Input }],
            layoutSettings: [{ type: core.Input }],
            activate: [{ type: core.Output }],
            deactivate: [{ type: core.Output }],
            zoomChange: [{ type: core.Output }],
            clickHandler: [{ type: core.Output }],
            linkTemplate: [{ type: core.ContentChild, args: ['linkTemplate', { static: false },] }],
            nodeTemplate: [{ type: core.ContentChild, args: ['nodeTemplate', { static: false },] }],
            clusterTemplate: [{ type: core.ContentChild, args: ['clusterTemplate', { static: false },] }],
            defsTemplate: [{ type: core.ContentChild, args: ['defsTemplate', { static: false },] }],
            chart: [{ type: core.ViewChild, args: [ngxCharts.ChartComponent, { read: core.ElementRef, static: true },] }],
            nodeElements: [{ type: core.ViewChildren, args: ['nodeElement',] }],
            linkElements: [{ type: core.ViewChildren, args: ['linkElement',] }],
            groupResultsBy: [{ type: core.Input }],
            zoomLevel: [{ type: core.Input, args: ['zoomLevel',] }],
            panOffsetX: [{ type: core.Input, args: ['panOffsetX',] }],
            panOffsetY: [{ type: core.Input, args: ['panOffsetY',] }],
            onMouseMove: [{ type: core.HostListener, args: ['document:mousemove', ['$event'],] }],
            onMouseDown: [{ type: core.HostListener, args: ['document:mousedown', ['$event'],] }],
            graphClick: [{ type: core.HostListener, args: ['document:click', ['$event'],] }],
            onTouchMove: [{ type: core.HostListener, args: ['document:touchmove', ['$event'],] }],
            onMouseUp: [{ type: core.HostListener, args: ['document:mouseup', ['$event'],] }]
        };
        return GraphComponent;
    }(ngxCharts.BaseChartComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Mousewheel directive
     * https://github.com/SodhanaLibrary/angular2-examples/blob/master/app/mouseWheelDirective/mousewheel.directive.ts
     *
     * @export
     */
    var MouseWheelDirective = /** @class */ (function () {
        function MouseWheelDirective() {
            this.mouseWheelUp = new core.EventEmitter();
            this.mouseWheelDown = new core.EventEmitter();
        }
        /**
         * @param {?} event
         * @return {?}
         */
        MouseWheelDirective.prototype.onMouseWheelChrome = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.mouseWheelFunc(event);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        MouseWheelDirective.prototype.onMouseWheelFirefox = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.mouseWheelFunc(event);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        MouseWheelDirective.prototype.onMouseWheelIE = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.mouseWheelFunc(event);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        MouseWheelDirective.prototype.mouseWheelFunc = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (window.event) {
                event = window.event;
            }
            /** @type {?} */
            var delta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));
            if (delta > 0) {
                this.mouseWheelUp.emit(event);
            }
            else if (delta < 0) {
                this.mouseWheelDown.emit(event);
            }
            // for IE
            event.returnValue = false;
            // for Chrome and Firefox
            if (event.preventDefault) {
                event.preventDefault();
            }
        };
        MouseWheelDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[mouseWheel]' },] }
        ];
        MouseWheelDirective.propDecorators = {
            mouseWheelUp: [{ type: core.Output }],
            mouseWheelDown: [{ type: core.Output }],
            onMouseWheelChrome: [{ type: core.HostListener, args: ['mousewheel', ['$event'],] }],
            onMouseWheelFirefox: [{ type: core.HostListener, args: ['DOMMouseScroll', ['$event'],] }],
            onMouseWheelIE: [{ type: core.HostListener, args: ['onmousewheel', ['$event'],] }]
        };
        return MouseWheelDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var GraphModule = /** @class */ (function () {
        function GraphModule() {
        }
        GraphModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [ngxCharts.ChartCommonModule],
                        declarations: [GraphComponent, MouseWheelDirective],
                        exports: [GraphComponent, MouseWheelDirective],
                        providers: [LayoutService]
                    },] }
        ];
        return GraphModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxGraphModule = /** @class */ (function () {
        function NgxGraphModule() {
        }
        NgxGraphModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [ngxCharts.NgxChartsModule],
                        exports: [GraphModule]
                    },] }
        ];
        return NgxGraphModule;
    }());

    exports.GraphComponent = GraphComponent;
    exports.NgxGraphModule = NgxGraphModule;
    exports.ɵa = GraphModule;
    exports.ɵb = LayoutService;
    exports.ɵc = MouseWheelDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=swimlane-ngx-graph.umd.js.map
